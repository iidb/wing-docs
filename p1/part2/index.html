<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Part 2 - Wing</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Part 2";
        var mkdocs_page_input_path = "p1\\part2.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Wing
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Project 1</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../overview/">Overview</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../part1/">Part 1</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Part 2</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#dbimplcompactionjob">DBImpl::CompactionJob</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#test">Test</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#leveled-compaction-strategy">Leveled compaction strategy</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dbimplcompactionthread">DBImpl::CompactionThread</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#putdel-operation">Put/Del operation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#locks-in-lsm-tree">Locks in LSM-tree</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#multiversion-concurrency-control-in-lsm-tree">Multiversion Concurrency Control in LSM-tree</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#task">Task</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#remove-old-sstables">Remove old SSTables</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#test_1">Test</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../part3/">Part 3</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Wing</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Project 1</li>
      <li class="breadcrumb-item active">Part 2</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="part-2">Part 2</h1>
<p>In part 2, you will implement compaction mechanism. You will implement: </p>
<ul>
<li>
<p><code>CompactionJob</code>. This component receives an iterator and persists its output as a list of SSTables. It is utilized in both <code>DBImpl::FlushThread</code> and <code>DBImpl::CompactionThread</code>.</p>
</li>
<li>
<p><code>LeveledCompactionPicker</code>, which is derived from <code>CompactionPicker</code>. It generates a new compaction task. The parameters for the compaction task are stored in <code>Compaction</code>. It returns nullptr if no compaction is required for the LSM-tree.</p>
</li>
<li>
<p><code>DBImpl::CompactionThread</code>. This thread manages the compaction process and updates the superversion. You may refer to the implementation of <code>DBImpl::FlushThread</code> for guidance.</p>
</li>
</ul>
<h2 id="dbimplcompactionjob">DBImpl::CompactionJob</h2>
<p>You will implement CompactionJob::Run. It receives an iterator and writes the iterator's output to disk. You should merge the records with the same key. The output is divided into SSTables, with the size of data blocks in SSTable not exceeding the target SSTable size (refer to <code>sst_file_size</code> in <code>storage/lsm/options.hpp</code>). The actual SSTable size may be larger than the target SSTable size since we have index data, bloom filter and metadata. </p>
<p>The code is in <code>compaction_job.hpp</code>.</p>
<h3 id="test">Test</h3>
<p>You can test it through <code>test/test_lsm --gtest_filter=LSMTest.CompactionBasicTest</code></p>
<h2 id="leveled-compaction-strategy">Leveled compaction strategy</h2>
<p>You will implement the leveled compaction strategy. This strategy is the default strategy of RocksDB.</p>
<p>The leveled compaction strategy in Wing is as follows: Suppose the size ratio is <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>, and the size limit of Level 0 is <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>. The size limit of Level 1, 2, 3 <span class="arithmatex"><span class="MathJax_Preview">\cdots</span><script type="math/tex">\cdots</script></span> is <span class="arithmatex"><span class="MathJax_Preview">BT,BT^2,BT^3\cdots</span><script type="math/tex">BT,BT^2,BT^3\cdots</script></span> Level 0 consists of multiple sorted runs flushed by <code>DBImpl::FlushThread</code>, each sorted run has 1 or 2 SSTables. If the number of sorted runs is larger than 4, all the sorted runs are compacted to the next level. If the number of sorted runs reaches 20, then <code>DBImpl::FlushThread</code> stops to flush until they are compacted to the next level. Level 1, 2, 3 <span class="arithmatex"><span class="MathJax_Preview">\cdots</span><script type="math/tex">\cdots</script></span> consists of only one sorted run. If one of them reaches its capacity, it picks an SSTable with the minimum overlapping with the next level, and compact the SSTable with the next level.</p>
<p>In LeveledCompactionPicker::Get, you must check for the existence of a compaction task. If one exists, you must create and return a <code>std::unique_ptr&lt;Compaction&gt;</code>. Otherwise, return a nullptr.</p>
<p>The code is in <code>compaction_picker.hpp</code>, <code>compaction_picker.cpp</code>, <code>compaction.hpp</code>.</p>
<h2 id="dbimplcompactionthread">DBImpl::CompactionThread</h2>
<h3 id="putdel-operation">Put/Del operation</h3>
<p>The <code>Put/Del</code> operation inserts a record into the LSM-tree. The key is converted to an internal key by adding the current sequence number and record type (<code>RecordType::Value</code> or <code>RecordType::Deletion</code>). Initially, it is inserted into the memtable. If the memtable reaches its capacity, it is appended to the list of immutable memtables. Then it nofities the flush thread. Then it installs the superversion (refer to <code>DBImpl::SwitchMemtable</code>).</p>
<p>The flush thread waits for the signal and fetches the list of immutable memtables. It flushes them (through <code>CompactionJob</code>) to sorted runs. Once the sorted runs are created, it creates a new superversion, installs the superversion, and notifies the compaction thread (refer to <code>DBImpl::FlushThread</code>). </p>
<p>The compaction thread waits for the signal from the flush thread. Upon awakening, it checks the levels and attempts to find a compaction task (refer to <code>CompactionPicker::Get</code> and <code>Compaction</code> in <code>lsm/compaction_pick.hpp</code> and <code>lsm/compaction.hpp</code>). For example, it may find that Level 0 is too large, so it creates a compaction task: compacting some SSTable files from Level 0 to Level 1. After new SSTable files are created, it creates a new superversion, installs the superversion and looks for compaction tasks again. It is possible that multiple compactions occur when one immutable memtable is flushed. It also add removal tags to useless SSTables, so that they will be removed while destruction. </p>
<h3 id="locks-in-lsm-tree">Locks in LSM-tree</h3>
<p>There are 3 locks in LSM-tree. We use concurrency primitives in C++, including <code>std::mutex</code>, <code>std::unique_lock</code>, <code>std::shared_mutex</code>(C++17), <code>std::shared_lock</code>(C++17), <code>std::condition_variable</code>.</p>
<p>The first is <code>db_mutex_</code>. This mutex is used to protect the process of operating metadata (e.g. switching memtables, creating new superversion and installing new superversions).</p>
<p>The second is <code>write_mutex_</code>. This mutex is used to protect <code>Put</code> operations. </p>
<p>The third is <code>sv_mutex_</code>. This mutex is used to protect the reference and installation of the superversion pointer.</p>
<h3 id="multiversion-concurrency-control-in-lsm-tree">Multiversion Concurrency Control in LSM-tree</h3>
<p>In LSM-tree, <code>Put</code> operations do not block <code>Get</code>/<code>Scan</code> (implemented by <code>DBIterator</code>) operations. This is achieved by supporting multiple superversions simultaneously. Each superversion has a reference count which is maintained by <code>std::shared_ptr</code>, the SSTables and the sorted runs in one superversion will not be removed if the reference count does not decrease to 0. For <code>Get</code> and Scan operations, a superversion is referenced, and the data accessed within this superversion remains consistent regardless of new superversions created by the <code>Put</code>/<code>FlushThread</code>/<code>CompactionThread</code>.</p>
<h3 id="task">Task</h3>
<p>You will implement <code>DBImpl::CompactionThread</code>.</p>
<p>The compaction thread awaits signals from the flush thread or the deconstructor via the condition variable <code>compact_cv_</code>. Upon being awakened, it first checks <code>stop_signal_</code>. If <code>stop_signal_</code> is true, it stops immediately. Otherwise, it calls <code>CompactionPicker::Get</code> to obtain a compaction task. If a task is present, it executes the compaction outside of the DB mutex. After compaction, it reacquires the DB mutex, creates a new superversion, and updates the DBImpl superversion. You can assume that the number of SSTables is small, allowing you to iterate through each SSTable and copy their pointers to the new superversion. You also need to set <code>compaction_flag_</code> to true if you are not waiting for <code>compact_cv_</code>, like <code>flush_flag_</code> in <code>DBImpl::FlushThread</code>. </p>
<p>More specifically, you need to write something like:</p>
<pre><code class="language-c++">void DBImpl::CompactionThread() {
  while (!stop_signal_) {
    std::unique_lock lck(db_mutex_);
    // Check if it has to stop. 
    // It has to stop when the LSM-tree shutdowns.
    if (stop_signal_) {
      compact_flag_ = false;
      return;
    }
    std::unique_ptr&lt;Compaction&gt; compaction = /* A new compaction task */
    if (!compaction) {
      compact_flag_ = false;
      compact_cv_.wait(lck);
      continue;
    }
    compact_flag_ = true;
    // Do some other things
    db_mutex_.unlock();
    // Do compaction
    db_mutex_.lock();
    // Create a new superversion and install it
  }
}
</code></pre>
<p>The DB mutex should only be used for metadata operations. You must avoid performing the compaction process under the DB mutex.</p>
<p>The code is in <code>lsm.cpp</code> and <code>lsm.hpp</code>.</p>
<h3 id="remove-old-sstables">Remove old SSTables</h3>
<p>Utilize SetRemoveTag to set the <code>remove_tag_</code> to true. When the destructor of SSTable is invoked, it checks the tag and determines whether to remove the file. This is safe as the destructor is called only when the SSTable is not in use.</p>
<h3 id="test_1">Test</h3>
<p>You can test all the components through <code>test/test_lsm --gtest_filter=LSMTest.LSMBasicTest:LSMTest.LSMSmallGetTest:LSMTest.LSMSmallScanTest:LSMTest.LSMSmallMultithreadGetPutTest:LSMTest.LSMSaveTest:LSMTest.LSMBigScanTest:LSMTest.LeveledCompactionTest</code></p>
<p>or, you can just use <code>test/test_lsm --gtest_filter=LSMTest.LSM*:LSMTest.LeveledCompactionTest</code></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../part1/" class="btn btn-neutral float-left" title="Part 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../part3/" class="btn btn-neutral float-right" title="Part 3">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../part1/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../part3/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
