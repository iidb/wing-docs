<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Part 3 - Wing</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Part 3";
        var mkdocs_page_input_path = "p1/part3.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Wing
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Project 1</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../overview/">Overview</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../part1/">Part 1</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../part2/">Part 2</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Part 3</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#problem-1-lazy-leveling-3pts">Problem 1: lazy leveling (3pts)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#problem-2-find-the-best-compaction-policy-4pts">Problem 2: find the best compaction policy (4pts)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#problem-3-find-the-best-compaction-policy-considering-range-filters-3pts">Problem 3: find the best compaction policy considering range filters (3pts)</a>
    </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Wing</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Project 1</li>
      <li class="breadcrumb-item active">Part 3</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="part-3-tradeoff-between-range-scan-and-compaction">Part 3: Tradeoff between range scan and compaction</h1>
<p>You should submit your code and report on the Web Learning 网络学堂. In the report, you need to write your answers to the problems.</p>
<h2 id="problem-1-lazy-leveling-3pts">Problem 1: lazy leveling (3pts)</h2>
<p>We previously implemented the leveling compaction policy: there is only one sorted run in each level, and the size of the latter level is <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> times the size of the former level. Therefore, the write amplification to compaction one key to the next level is <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>. If there are <span class="arithmatex"><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span> levels, the write amplification is <span class="arithmatex"><span class="MathJax_Preview">TL</span><script type="math/tex">TL</script></span>.</p>
<p>Tiering is another compaction policy: there are at most <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> sorted runs in each level, and when the number of sorted runs in a level reaches <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>, all <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> sorted runs will be merged (i.e., compacted) into a new sorted run in the next level. Since for each key, it can only be compacted from one level to the next level, a key will be compacted at most <span class="arithmatex"><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span> times if there are <span class="arithmatex"><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span> levels. Thus the write amplification of the tiering policy is <span class="arithmatex"><span class="MathJax_Preview">O(L)</span><script type="math/tex">O(L)</script></span>. It is smaller than the write amplification of leveling strategy <span class="arithmatex"><span class="MathJax_Preview">O(TL)</span><script type="math/tex">O(TL)</script></span>. </p>
<p>However, the tiering policy suffers from high space amplification. In the worst case, there can be <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> duplicate sorted runs in the last level, and the space amplification can be <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>. It is unacceptable. Thus, lazy leveling is proposed. Lazy leveling combines the advantages of the leveling policy and the tiering policy. Suppose there are <span class="arithmatex"><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span> levels in total. Lazy leveling uses the tiering compaction policy in Level <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>, Level <span class="arithmatex"><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\cdots</span><script type="math/tex">\cdots</script></span>, Level <span class="arithmatex"><span class="MathJax_Preview">L-1</span><script type="math/tex">L-1</script></span> to reduce the write amplification. The maximum number of sorted runs in these levels is <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>. Lazy leveling limits the space amplification by allowing only one sorted run in the last level. When the number of sorted runs in Level <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>, <span class="arithmatex"><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\cdots</span><script type="math/tex">\cdots</script></span>, <span class="arithmatex"><span class="MathJax_Preview">L-2</span><script type="math/tex">L-2</script></span> reaches <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>, all these sorted runs in the respective level will be merged into a new sorted run in the next level. When the number of sorted runs in Level <span class="arithmatex"><span class="MathJax_Preview">L-1</span><script type="math/tex">L-1</script></span> reaches <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>, all sorted runs in it will be merged into the sorted run in Level <span class="arithmatex"><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span>.</p>
<p>Here we analyze the write amplification of lazy leveling. Similar to the tiering policy, each non-last level contributes <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> to the write amplification. The last level uses the leveling compaction policy, therefore it contributes <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> to the write amplification, where <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> is the size ratio between Level <span class="arithmatex"><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span> and Level <span class="arithmatex"><span class="MathJax_Preview">L-1</span><script type="math/tex">L-1</script></span>. Therefore, the total write amplification is <span class="arithmatex"><span class="MathJax_Preview">L - 1 + C</span><script type="math/tex">L - 1 + C</script></span>. The write cost <span class="arithmatex"><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is <span class="arithmatex"><span class="MathJax_Preview">(L - 1 + C)(input\ size)</span><script type="math/tex">(L - 1 + C)(input\ size)</script></span>.</p>
<p>Your tasks are as follows:</p>
<ol>
<li>
<p>Implement lazy leveling in <code>LazyLevelingCompactionPicker::Get</code>. You can test it through <code>test/test_lsm --gtest_filter=LSMTest.LazyLevelingCompactionTest</code>. Please submit to autolab.</p>
</li>
<li>
<p>Measure the write amplification in the test and compare it with the theoretical write amplification <span class="arithmatex"><span class="MathJax_Preview">L - 1 + C</span><script type="math/tex">L - 1 + C</script></span> in the report. If they are different, please analyze the reason.</p>
</li>
</ol>
<h2 id="problem-2-find-the-best-compaction-policy-4pts">Problem 2: find the best compaction policy (4pts)</h2>
<p>Range scan is a query type that retrieves all records in the given range. To scan a range, we first seek the begin key in all sorted runs, and then sequentially read subsequent records until the end of the range. In problem 2 and problem 3, we only consider short range scan (scan length <span class="arithmatex"><span class="MathJax_Preview">\leq 100</span><script type="math/tex">\leq 100</script></span>). We assume that for each sorted run, we read only one block. So the range scan cost for lazy leveling is <span class="arithmatex"><span class="MathJax_Preview">(1 + T (L-1))(block\ size)</span><script type="math/tex">(1 + T (L-1))(block\ size)</script></span>, where <span class="arithmatex"><span class="MathJax_Preview">1 + T(L-1)</span><script type="math/tex">1 + T(L-1)</script></span> is the number of sorted runs.</p>
<p>We can generalize the lazy leveling compaction policy by allowing different maximum numbers of sorted runs in non-last levels. Specifically, for Level <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> where <span class="arithmatex"><span class="MathJax_Preview">i &lt; L</span><script type="math/tex">i < L</script></span>, we designate the maximum number of sorted runs as <span class="arithmatex"><span class="MathJax_Preview">k_i</span><script type="math/tex">k_i</script></span>. We model the total cost of compactions and range scans in the generalized lazy leveling policy as <span class="arithmatex"><span class="MathJax_Preview">f(\vec k, C) = w(\vec k, C) + \alpha r(\vec k)</span><script type="math/tex">f(\vec k, C) = w(\vec k, C) + \alpha r(\vec k)</script></span>. The write cost <span class="arithmatex"><span class="MathJax_Preview">w(\vec k, C) = (L - 1 + C)(input\ size)</span><script type="math/tex">w(\vec k, C) = (L - 1 + C)(input\ size)</script></span>. The read cost <span class="arithmatex"><span class="MathJax_Preview">r(\vec k)</span><script type="math/tex">r(\vec k)</script></span> is what you need to model. <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> describes the workload: a small <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> for a write-heavy workload and a large <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> for a scan-heavy workload.</p>
<p>Your task: given the size of the last level <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>, the base level size <span class="arithmatex"><span class="MathJax_Preview">F</span><script type="math/tex">F</script></span>, the workload parameter <span class="arithmatex"><span class="MathJax_Preview">alpha</span><script type="math/tex">alpha</script></span>, find <span class="arithmatex"><span class="MathJax_Preview">\vec k</span><script type="math/tex">\vec k</script></span> and <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> that minimize <span class="arithmatex"><span class="MathJax_Preview">f(\vec k, C)</span><script type="math/tex">f(\vec k, C)</script></span> and satisfy <span class="arithmatex"><span class="MathJax_Preview">N = \prod_{i=1}^{L-1} k_i F C</span><script type="math/tex">N = \prod_{i=1}^{L-1} k_i F C</script></span>. You need to design an algorithm to calculate optimal <span class="arithmatex"><span class="MathJax_Preview">\vec k, C</span><script type="math/tex">\vec k, C</script></span> based on parameters. More specifically, you need to implement <code>FluidCompactionPicker::Get</code> and adjust the maximum number of sorted runs in each level based on your algorithms. You may explore when and how to adjust the maximum number of sorted runs in each level. For example, you may calculate the optimal <span class="arithmatex"><span class="MathJax_Preview">\vec k</span><script type="math/tex">\vec k</script></span> and <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> for every 5 seconds and apply the changes only when the optimal <span class="arithmatex"><span class="MathJax_Preview">\vec k</span><script type="math/tex">\vec k</script></span> or <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> differs much from the current value. </p>
<p>We provide a basic benchmark that can be executed by <code>test/test_lsm --gtest_filter=LSMTest.Part3Benchmark1</code>. Your algorithm should outperform than the baseline. There is no need to submit to autolab due to the long execution time.</p>
<p>Please write a report detailing the algorithm you have designed and implemented. Additionally, include a comprehensive comparison with other compaction policies. Compare your algorithm with other compaction policies, including leveling, tiering, and lazy leveling in problem 1. Furthermore, adjust the <code>alpha</code> value in the benchmark (passing different <code>alpha</code> value to <code>Part3Benchmark</code> function), and determine the range of <code>alpha</code> where your algorithm performs the best. </p>
<p>The parameters in <code>Part3Benchmark(alpha, N, scan_length)</code> are: <code>alpha</code> value, <code>N</code> is the number of keys, <code>scan_length</code> is the length of range scan. <code>scan_length</code> is set to be larger than <code>N</code> in this problem.</p>
<p>You can get points as long as your solution is reasonable and well-founded.</p>
<h2 id="problem-3-find-the-best-compaction-policy-considering-range-filters-3pts">Problem 3: find the best compaction policy considering range filters (3pts)</h2>
<p>Similar to bloom filters, there are also range filters. They can determine whether keys exist within a specified range in a sorted run. It allows range scans to skip sorted runs without relevant keys, optimizing query performance. We assume that we have a perfect range filter which does not produce false positives. Using this range filter, we can calculate the read cost based on the expected number of sorted runs that need to read. We also assume that the length <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> of range scan is always the same.</p>
<p>Let the total size of LSM-tree be <span class="arithmatex"><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>. Suppose there is a sorted run of size <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> in the LSM-tree. Assuming that all the keys in the LSM-tree are unique and uniformly distributed, for a range scan of length <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>, the probability that a key from the sorted run will be in the result of the range scan is <span class="arithmatex"><span class="MathJax_Preview">1 - \prod_{i=0}^{m-1}\frac{S-T-i}{S-i}</span><script type="math/tex">1 - \prod_{i=0}^{m-1}\frac{S-T-i}{S-i}</script></span>. You can consider for the first key in the result of the range scan, the probability that the key is not in the sorted run is <span class="arithmatex"><span class="MathJax_Preview">\frac{S-T}{S}</span><script type="math/tex">\frac{S-T}{S}</script></span>, and for the second key it is <span class="arithmatex"><span class="MathJax_Preview">\frac{S-T-1}{S-1}</span><script type="math/tex">\frac{S-T-1}{S-1}</script></span>, and so on. This probability is approximately <span class="arithmatex"><span class="MathJax_Preview">\approx 1-(1-\frac{T}{S})^m\approx 1-e^{-mT/S}</span><script type="math/tex">\approx 1-(1-\frac{T}{S})^m\approx 1-e^{-mT/S}</script></span>. Then the read cost can be calculated by <span class="arithmatex"><span class="MathJax_Preview">r(\vec k)=(\sum_{T} 1-e^{-mT/S})(block\ size)</span><script type="math/tex">r(\vec k)=(\sum_{T} 1-e^{-mT/S})(block\ size)</script></span>. The write cost is the same as problem 2.</p>
<p>The code of estimation is in <code>Part3Benchmark</code> function.</p>
<p>Your task: given the size of the last level <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>, the base level size <span class="arithmatex"><span class="MathJax_Preview">F</span><script type="math/tex">F</script></span>, the workload parameter <span class="arithmatex"><span class="MathJax_Preview">alpha</span><script type="math/tex">alpha</script></span>, and the range scan length <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>, approximate the read cost and write cost, find <span class="arithmatex"><span class="MathJax_Preview">\vec k, C</span><script type="math/tex">\vec k, C</script></span> that minimize <span class="arithmatex"><span class="MathJax_Preview">f(\vec k, C) = w(\vec k, C) + \alpha r(\vec k)</span><script type="math/tex">f(\vec k, C) = w(\vec k, C) + \alpha r(\vec k)</script></span> and satisfy <span class="arithmatex"><span class="MathJax_Preview">N = \prod_{i=1}^{L-1} k_i C F</span><script type="math/tex">N = \prod_{i=1}^{L-1} k_i C F</script></span>. You need to implement it in <code>FluidCompactionPicker::Get</code>.</p>
<p>We provide a basic benchmark that can be executed by <code>test/test_lsm --gtest_filter=LSMTest.Part3Benchmark2</code>. Your algorithm should outperform than the baseline. There is no need to submit to autolab due to the long execution time.</p>
<p>Please write a report detailing the algorithm you have designed and implemented. Additionally, include a comprehensive comparison with other compaction policies. Compare your algorithm with other compaction policies, including leveling, tiering, and lazy leveling in problem 1. Furthermore, adjust the <code>alpha</code> value in the benchmark, and determine the range of <code>alpha</code> where your algorithm performs the best.</p>
<p>The parameters in <code>Part3Benchmark(alpha, N, scan_length)</code> are: <code>alpha</code> value, <code>N</code> is the number of keys, <code>scan_length</code> is the length of range scan. <code>scan_length</code> is set to 100 by default. You can also pass different <code>scan_length</code> to this function.</p>
<p>You can get points as long as your solution is reasonable and well-founded.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../part2/" class="btn btn-neutral float-left" title="Part 2"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../part2/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
